[TOC]



## 数据结构

### 树

**二叉搜索树**、**平衡二叉查找树（AVL 树）**、**B树、B+树**、**红黑树**

MySQL数据库innodb

update submittal set del_flag=1 where open_id='ou_8e6bb6cdec065c5e3d73b02afcf1c24d';



## 计算机网络

TCP  层次关系，三次握手

UDP

HTTP 



## Go

切片

map

接口

通道

标准库 reflect context unsafe

调度器

垃圾回收



## C++

内存模型

标准库

虚函数

effective C++

## 消息队列

RocketMQ

https://www.cnblogs.com/makemylife/p/17015499.html

## 数据库

MySQL innodb 表是索引组织表

**聚集索引**：物理存储按照**索引**排序；**聚集索引**是一种**索引**组织形式，**索引**的键值逻辑顺序决定了表数据行的物理存储顺序 **非聚集索引**：物理存储不按照**索引**排序；**非聚集索引**则就是普通**索引**了，仅仅只是对数据列创建相应的**索引**，不影响整个表的物理存储顺序

MySQL表都有且仅有一个聚集索引，聚集索引是MySQL表存储数据的实现方式，也就是说表中的所有数据是通过一个聚集索引来组织的；这就有一个特性

>   如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页
>
>   2、如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。



+   表

    +   索引

        +   聚集索引
        +   非聚集索引
        +   索引优化
            +   索引尽量覆盖要查询的数据，尽量使用到复合索引（如：索引A,B,C，查询B,C使用不到索引，A,B就可以）

    +   B+树

        +   所有数据都在

    +   undo log：保存数据的历史版本，

        +   MVCC：查询当前的快照数据。
        +   事务回滚，保证事务的原子性，执行失败回滚到最初状态。

    +   redo log

    +   binlog：主从同步，审计判断是否有注入，

    +   事务

        +   原子性（**Atomicity**）：undo log来保证。

        +   一致性（**Consistent**）：

        +   隔离性（**Isolation**）：

            +   隔离级别，读未提交，读已提交，可重复读，串行化。
            +   锁，mvcc。

        +   持久性（**Durable**）：通过 redo

        +   并发问题：脏读，不可重复读，幻读。通过不同的隔离级别来保证。

            