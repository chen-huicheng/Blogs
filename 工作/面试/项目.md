## 预约排班模块

#### 术语解释：

-   **预约**：为用户与某个医生的号源进行关联（预约有不同类型）
-   **患者**：健康管理用户
-   **排班**：可以为医生按天配置的出诊安排
-   **资源（号源）**：可以预约的每一个最小时间段（号源有不同类型）
-   **配额**：每一个最小时间段可预约的资源数量/容量
    -   最大配额（排班时设置的最大可预约数）
    -   当前配额（剩余可预约数)
-   **举例**：
    -   张医生 2023-06-01（排班）出诊，可预约时间段  14:00 - 14:30（号源） ，2个号（最大配额）；两个人按照到院顺序进行就诊；
    -   患者张三预约了张医生

#### 预约排班映射关系

预约包含不同的类型，每个类型相当于医院的不同科室（眼科，骨科等），每个预约对应一个类型排班，每日排班包含多个医生的排班。

![](https://raw.githubusercontent.com/chen-huicheng/ImageHub/main/typora_img/202307131044487.svg)

通过医生-日期-排班类型来唯一标识一个排班。一个排班对应对个号源。

![](https://raw.githubusercontent.com/chen-huicheng/ImageHub/main/typora_img/202307131045644.svg)

排班实现的难点主要在，新建排班时排班互斥的校验。

预约的相关操作通过数据库事务来保证，创建预约记录和扣减号源是一个原子操作。

事务四大特性：

+   原子性（**Atomicity**）：undo log来保证。

+   一致性（**Consistent**）：

+   隔离性（**Isolation**）：

    +   隔离级别，读未提交，读已提交，可重复读，串行化。
    +   锁，mvcc。

+   持久性（**Durable**）：通过 redo

使用RocketMQ实现异步消息的发送，创建预约，改约，取消预约时会向消息队列发送一个消息，有一个单独的服务消费消息，并根据消息类型做一下操作，发送短信，创建日程等。

在实际生产中会有一个问题，因为服务是多机房部署，而使用的 RocketMQ 保证消息有序性是建立在但集群下的，而用户的请求是根据负载均衡随机路由到各个机房，我们无法安照期望的顺序进行消费。

实际情况是预约相关消息内有一个创建日程的操作，创建预约对应创建日程，并记录日程ID，取消预约根据预约ID进行取消。用户创建预约后，立马取消预约，对应的消息并不是有序的，取消日程时拿不到对应的日程ID，也就导致用户取消后，日程并没有取消。

解决方法是将用户的每次请求都路由到同一机房。

App[业务代码 --> TTNet网络库（网络请求 TNC配置）]-->具体机房。



为什么要用消息队列：优点-解耦，**异步**，削峰。

缺点-增加了系统的复杂性。比如消息**重复消费**、**消息丢失**、**消息的顺序消费**等等。
